<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Vineyard Teleoperation Platform</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#111;color:#eee;font-family:sans-serif}
#stage{width:100%;height:100%;display:block}
#hud{position:absolute;top:4px;left:4px;font-size:12px;background:rgba(0,0,0,0.4);padding:4px;border-radius:4px}
#help{position:absolute;top:4px;right:4px;font-size:12px;background:rgba(0,0,0,0.8);padding:8px;display:none;max-width:300px}
#log{position:absolute;bottom:4px;left:4px;font-size:11px;background:rgba(0,0,0,0.4);padding:4px;border-radius:4px;max-width:220px}
#buttons{position:absolute;bottom:4px;right:4px;display:flex;gap:4px}
#buttons button{font-size:12px;padding:4px 6px}
#sliders{position:absolute;top:4px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.4);padding:4px;border-radius:4px;font-size:12px;display:flex;gap:8px;align-items:center}
</style>
</head>
<body>
<div id="stage"></div>
<div id="hud"></div>
<div id="help"></div>
<div id="log"></div>
<div id="buttons">
  <button id="btnTraverse">Traverse</button>
  <button id="btnTransfer">Transfer</button>
  <button id="btnTeleop">Teleop</button>
  <button id="btnWork">Work</button>
  <button id="btnDock">Dock</button>
  <button id="btnEstop">E-Stop</button>
</div>
<div id="sliders">
  <label>Carriage <input id="carriageSpeed" type="range" min="0.2" max="2" step="0.1" value="1"></label>
  <label>Joint <input id="jointSpeed" type="range" min="10" max="90" step="5" value="30"></label>
  <label>Transfer <input id="transferSpeed" type="range" min="0.2" max="1.5" step="0.1" value="0.5"></label>
</div>
<script type="module">
// MIT License
// Copyright (c) 2024

import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
import {OrbitControls} from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js?module';

// ---- constants ----
const ROWS=6;            // number of rows
const ROW_LEN=80;        // meters
const ROW_SPACING=2.5;   // meters between rows
const CORDON_Z=1.0;      // meters
const WIRE1_Z=1.2;
const WIRE2_Z=1.3;
const OVERHEAD_Z=3.0;
const HEADLAND_X=-2;     // X position of overhead traverse wire

// ---- renderer / scene / camera ----
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.getElementById('stage').appendChild(renderer.domElement);
renderer.shadowMap.enabled=true;

const scene=new THREE.Scene();
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dir=new THREE.DirectionalLight(0xffffff,0.6);
dir.position.set(10,10,5);
dir.castShadow=true;
scene.add(dir);

const camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,500);
camera.position.set(-10,5,10);
const controls=new OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;

// teleoperation helpers
const raycaster=new THREE.Raycaster();
const pointer=new THREE.Vector2();
const targetMarker=new THREE.Mesh(new THREE.SphereGeometry(0.05,8,8),new THREE.MeshBasicMaterial({color:0xff0000}));
targetMarker.visible=false;
scene.add(targetMarker);

// ground plane + grid
const ground=new THREE.Mesh(new THREE.PlaneGeometry(120,40),new THREE.MeshStandardMaterial({color:0x333333}));
ground.rotation.x=-Math.PI/2;
ground.receiveShadow=true;
scene.add(ground);
scene.add(new THREE.GridHelper(120,60,0x444444,0x222222));

// ---- vineyard geometry ----
const posts=new THREE.Group();
const wires=new THREE.Group();
const cordons=new THREE.Group();
scene.add(posts);scene.add(wires);scene.add(cordons);

for(let r=0;r<ROWS;r++){
  const rowY=r*ROW_SPACING; // across-row coordinate -> three.js z
  // twin wires along row
  for(let j=0;j<2;j++){
    const zlevel=j===0?WIRE1_Z:WIRE2_Z;
    const path=new THREE.LineCurve3(
      new THREE.Vector3(0,zlevel,rowY),
      new THREE.Vector3(ROW_LEN,zlevel,rowY));
    const tube=new THREE.TubeGeometry(path,1,0.01,8,false);
    const mesh=new THREE.Mesh(tube,new THREE.MeshStandardMaterial({color:0x888888}));
    mesh.castShadow=true;mesh.receiveShadow=true;
    wires.add(mesh);
  }
  // posts every 5 m
  for(let x=0;x<=ROW_LEN;x+=5){
    const radius=(x===0||x===ROW_LEN)?0.06:0.04;
    const height=1.6;
    const post=new THREE.Mesh(new THREE.CylinderGeometry(radius,radius,height,8),new THREE.MeshStandardMaterial({color:0x8B5A2B}));
    post.position.set(x,height/2,rowY);
    if(x===0) post.rotation.z=THREE.MathUtils.degToRad(-10);
    if(x===ROW_LEN) post.rotation.z=THREE.MathUtils.degToRad(10);
    post.castShadow=true;post.receiveShadow=true;
    posts.add(post);
  }
  // cordon stubs every 0.5 m
  for(let x=0;x<=ROW_LEN;x+=0.5){
    const stub=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.1,6),new THREE.MeshStandardMaterial({color:0xAA7744}));
    stub.position.set(x,CORDON_Z,rowY);
    cordons.add(stub);
  }
}

// overhead traverse wire and drop lines
const overhead=new THREE.Group();
scene.add(overhead);
const overPath=new THREE.LineCurve3(
  new THREE.Vector3(HEADLAND_X,OVERHEAD_Z,0),
  new THREE.Vector3(HEADLAND_X,OVERHEAD_Z,(ROWS-1)*ROW_SPACING));
const overGeo=new THREE.TubeGeometry(overPath,1,0.02,8,false);
overhead.add(new THREE.Mesh(overGeo,new THREE.MeshStandardMaterial({color:0xaaaaaa})));
for(let r=0;r<ROWS;r++){
  const y=r*ROW_SPACING;
  const dPath=new THREE.LineCurve3(
    new THREE.Vector3(HEADLAND_X,OVERHEAD_Z,y),
    new THREE.Vector3(HEADLAND_X,WIRE1_Z,y));
  const dGeo=new THREE.TubeGeometry(dPath,1,0.01,8,false);
  overhead.add(new THREE.Mesh(dGeo,new THREE.MeshStandardMaterial({color:0xaaaaaa})));
  const cPath=new THREE.LineCurve3(
    new THREE.Vector3(HEADLAND_X,WIRE1_Z,y),
    new THREE.Vector3(0,WIRE1_Z,y));
  const cGeo=new THREE.TubeGeometry(cPath,1,0.01,8,false);
  overhead.add(new THREE.Mesh(cGeo,new THREE.MeshStandardMaterial({color:0xaaaaaa})));
}

// dock/service
const dock=new THREE.Group();
dock.position.set(HEADLAND_X-1,0.25,-2);
const dockBase=new THREE.Mesh(new THREE.BoxGeometry(1,0.5,1),new THREE.MeshStandardMaterial({color:0x555555}));
dock.add(dockBase);
const panel=new THREE.Mesh(new THREE.PlaneGeometry(1,0.6),new THREE.MeshStandardMaterial({color:0x2222ff}));
panel.position.set(0,0.5,0);
panel.rotation.x=-Math.PI/4;
dock.add(panel);
const battery=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,0.6,12),new THREE.MeshStandardMaterial({color:0x00ff00}));
battery.position.set(0.4,0.3,0);
dock.add(battery);
scene.add(dock);

// ---- carriage + arm ----
const carriage=new THREE.Group();
const body=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.4),new THREE.MeshStandardMaterial({color:0x4444ff}));
body.castShadow=true;body.receiveShadow=true;
carriage.add(body);
const wheelGeo=new THREE.CylinderGeometry(0.05,0.05,0.1,12);
wheelGeo.rotateZ(Math.PI/2);
const wheelMat=new THREE.MeshStandardMaterial({color:0x222222});
const wheel1=new THREE.Mesh(wheelGeo,wheelMat);wheel1.position.set(0,-0.05,0.15);
const wheel2=wheel1.clone();wheel2.position.z=-0.15;
carriage.add(wheel1);carriage.add(wheel2);
const tetherGeo=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0.1,0),new THREE.Vector3(0,2,0)]);
const tether=new THREE.Line(tetherGeo,new THREE.LineBasicMaterial({color:0xff0000}));
carriage.add(tether);
scene.add(carriage);

// arm segments
const L1=0.25,L2=0.30,L3=0.20,L4=0.10;
const joints={yaw:0,shoulder:0,elbow:0,wristPitch:0,wristRoll:0,gripper:0};
const base=new THREE.Group();
base.position.set(0,0.1,0);
carriage.add(base);
const yawJoint=new THREE.Group();
base.add(yawJoint);
const shoulder=new THREE.Group();
yawJoint.add(shoulder);
const upper=new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,L1,12),new THREE.MeshStandardMaterial({color:0xffaa00}));
upper.position.y=L1/2;
shoulder.add(upper);
const elbow=new THREE.Group();
elbow.position.y=L1;
shoulder.add(elbow);
const fore=new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.025,L2,12),new THREE.MeshStandardMaterial({color:0xffaa00}));
fore.position.y=L2/2;
elbow.add(fore);
const wristPitch=new THREE.Group();
wristPitch.position.y=L2;
elbow.add(wristPitch);
const wrist=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,L3,12),new THREE.MeshStandardMaterial({color:0xffaa00}));
wrist.position.y=L3/2;
wristPitch.add(wrist);
const wristRoll=new THREE.Group();
wristRoll.position.y=L3;
wristPitch.add(wristRoll);
const tool=new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,L4,12),new THREE.MeshStandardMaterial({color:0x999999}));
tool.rotation.x=Math.PI/2;tool.position.y=L4/2;
wristRoll.add(tool);
const axes=new THREE.AxesHelper(0.1);
axes.position.y=L4;
wristRoll.add(axes);
const reachSphere=new THREE.Mesh(new THREE.SphereGeometry(0.4,16,16),new THREE.MeshBasicMaterial({color:0x00ff00,transparent:true,opacity:0.1}));
reachSphere.visible=false;
wristRoll.add(reachSphere);

function applyJoints(){
  yawJoint.rotation.y=THREE.MathUtils.degToRad(joints.yaw);
  shoulder.rotation.z=THREE.MathUtils.degToRad(joints.shoulder);
  elbow.rotation.z=THREE.MathUtils.degToRad(joints.elbow);
  wristPitch.rotation.z=THREE.MathUtils.degToRad(joints.wristPitch);
  wristRoll.rotation.y=THREE.MathUtils.degToRad(joints.wristRoll);
}

// ---- state ----
let mode='Traverse';
let currentRow=0; // 0..ROWS-1
let xPos=0; // along row
let zPos=currentRow*ROW_SPACING; // across rows in transfer
let transferY=OVERHEAD_Z; // used in transfer
let estop=false;
let toolMode='Pruner';
let teleTarget=null;

carriage.position.set(0,WIRE1_Z+0.05,currentRow*ROW_SPACING);

// ---- controls ----
const keys={};
window.addEventListener('keydown',e=>{
  keys[e.code]=true;
  if(e.code==='Slash' && e.shiftKey) toggleHelp();
  if(e.code==='KeyP'){toolMode=toolMode==='Pruner'?'Brush':'Pruner';logEvent('Tool '+toolMode);}
  if(e.code==='Enter'){logEvent('Tool action');}
  if(e.code==='Home') attachOverhead();
  if(e.code==='End') attachRow();
  if(e.code==='Space') toggleEstop();
});
window.addEventListener('keyup',e=>{keys[e.code]=false;});

document.getElementById('btnTraverse').onclick=attachRow;
document.getElementById('btnTransfer').onclick=attachOverhead;
document.getElementById('btnTeleop').onclick=()=>{mode='Teleop';teleTarget=null;targetMarker.visible=false;logEvent('Teleop mode');};
document.getElementById('btnWork').onclick=()=>{mode='Work';teleTarget=null;targetMarker.visible=false;logEvent('Work mode');};
document.getElementById('btnDock').onclick=()=>{carriage.position.set(HEADLAND_X-1,0.25,-2);xPos=0;mode='Traverse';teleTarget=null;targetMarker.visible=false;logEvent('Dock');};
document.getElementById('btnEstop').onclick=toggleEstop;

let carriageSpeed=parseFloat(localStorage.getItem('carriageSpeed')||'1');
let jointSpeed=parseFloat(localStorage.getItem('jointSpeed')||'30');
let transferSpeed=parseFloat(localStorage.getItem('transferSpeed')||'0.5');
const cs=document.getElementById('carriageSpeed');cs.value=carriageSpeed;cs.oninput=e=>{carriageSpeed=parseFloat(e.target.value);localStorage.setItem('carriageSpeed',carriageSpeed);};
const js=document.getElementById('jointSpeed');js.value=jointSpeed;js.oninput=e=>{jointSpeed=parseFloat(e.target.value);localStorage.setItem('jointSpeed',jointSpeed);};
const ts=document.getElementById('transferSpeed');ts.value=transferSpeed;ts.oninput=e=>{transferSpeed=parseFloat(e.target.value);localStorage.setItem('transferSpeed',transferSpeed);};

// ---- HUD & Help ----
const hud=document.getElementById('hud');
const help=document.getElementById('help');
help.innerHTML=`<b>Keymap</b><br>
Arrow Left/Right: move<br>
Ctrl+←/→: change row (Traverse/Teleop)<br>
Arrow Up/Down: move between rows (Transfer)<br>
Home: to overhead<br>End: to row<br>
PageUp/PageDown: raise/lower (Transfer)<br>
Q/A,W/S,E/D,R/F,T/G,Y/H: joints<br>
P: toggle tool, Enter: action<br>
Teleop: click to set destination<br>
Space: E-Stop<br>? : toggle help`;

function toggleHelp(){help.style.display=help.style.display==='none'||help.style.display===''?'block':'none';}

const logDiv=document.getElementById('log');
const logs=[];
function logEvent(msg){logs.push(msg);while(logs.length>6)logs.shift();logDiv.innerHTML=logs.join('<br>');}

function toggleEstop(){estop=!estop;teleTarget=null;targetMarker.visible=false;logEvent(estop?'E-STOP':'Resume');if(estop) mode='Traverse';}

function attachOverhead(){
  mode='Transfer';
  teleTarget=null;targetMarker.visible=false;
  transferY=OVERHEAD_Z;
  xPos=HEADLAND_X;
  zPos=currentRow*ROW_SPACING;
  carriage.position.set(xPos,transferY,zPos);
  logEvent('Transfer mode');
}
function attachRow(){
  mode='Traverse';
  teleTarget=null;targetMarker.visible=false;
  currentRow=Math.round(zPos/ROW_SPACING);
  carriage.position.set(xPos,WIRE1_Z+0.05,currentRow*ROW_SPACING);
  logEvent('Traverse mode');
}

renderer.domElement.addEventListener('click',e=>{
  if(mode!=='Teleop') return;
  pointer.x=(e.clientX/window.innerWidth)*2-1;
  pointer.y=-(e.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(pointer,camera);
  const plane=new THREE.Plane(new THREE.Vector3(0,0,1),-currentRow*ROW_SPACING);
  const pos=new THREE.Vector3();
  if(raycaster.ray.intersectPlane(plane,pos)){
    teleTarget=THREE.MathUtils.clamp(pos.x,0,ROW_LEN);
    targetMarker.position.set(teleTarget,WIRE1_Z+0.1,currentRow*ROW_SPACING);
    targetMarker.visible=true;
    logEvent(`Target ${teleTarget.toFixed(2)}m`);
  }
});

// ---- animation loop ----
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt=clock.getDelta();
  controls.update();
  if(!estop){
    if(mode==='Traverse'){
      let dir=0;
      if(keys['ArrowLeft'])dir=-1;
      if(keys['ArrowRight'])dir=1;
      xPos=THREE.MathUtils.clamp(xPos+dir*carriageSpeed*dt,0,ROW_LEN);
      if(keys['ArrowLeft']&&keys['ControlLeft']&&xPos<=0&&currentRow>0){currentRow--;zPos=currentRow*ROW_SPACING;xPos=0;}
      if(keys['ArrowRight']&&keys['ControlLeft']&&xPos>=ROW_LEN&&currentRow<ROWS-1){currentRow++;zPos=currentRow*ROW_SPACING;xPos=ROW_LEN;}
      carriage.position.set(xPos,WIRE1_Z+0.05,currentRow*ROW_SPACING);
    }else if(mode==='Teleop'){
      let dir=0;
      if(keys['ArrowLeft'])dir=-1;
      if(keys['ArrowRight'])dir=1;
      if(dir!==0){
        teleTarget=null;targetMarker.visible=false;
        xPos=THREE.MathUtils.clamp(xPos+dir*carriageSpeed*dt,0,ROW_LEN);
        if(keys['ControlLeft']&&dir<0&&xPos<=0&&currentRow>0){currentRow--;zPos=currentRow*ROW_SPACING;xPos=0;}
        if(keys['ControlLeft']&&dir>0&&xPos>=ROW_LEN&&currentRow<ROWS-1){currentRow++;zPos=currentRow*ROW_SPACING;xPos=ROW_LEN;}
      }else if(teleTarget!==null){
        const delta=teleTarget-xPos;
        const step=Math.sign(delta)*carriageSpeed*dt;
        if(Math.abs(delta)<=Math.abs(step)){
          xPos=teleTarget;teleTarget=null;targetMarker.visible=false;
        }else{
          xPos+=step;
        }
      }
      carriage.position.set(xPos,WIRE1_Z+0.05,currentRow*ROW_SPACING);
    }else if(mode==='Transfer'){
      if(keys['PageUp']) transferY=THREE.MathUtils.clamp(transferY+transferSpeed*dt,WIRE1_Z+0.05,OVERHEAD_Z);
      if(keys['PageDown']) transferY=THREE.MathUtils.clamp(transferY-transferSpeed*dt,WIRE1_Z+0.05,OVERHEAD_Z);
      let dir=0;
      if(keys['ArrowLeft']) dir=-1;
      if(keys['ArrowRight']) dir=1;
      xPos=THREE.MathUtils.clamp(xPos+dir*carriageSpeed*dt,HEADLAND_X,0);
      let zdir=0;
      if(keys['ArrowUp']) zdir=-1;
      if(keys['ArrowDown']) zdir=1;
      zPos=THREE.MathUtils.clamp(zPos+zdir*carriageSpeed*dt,0,(ROWS-1)*ROW_SPACING);
      currentRow=Math.round(zPos/ROW_SPACING);
      carriage.position.set(xPos,transferY,zPos);
    }else if(mode==='Work'){
      let dir=0;
      if(keys['ArrowLeft'])dir=-1;
      if(keys['ArrowRight'])dir=1;
      xPos=THREE.MathUtils.clamp(xPos+dir*carriageSpeed*0.25*dt,0,ROW_LEN);
      carriage.position.set(xPos,WIRE1_Z+0.05,currentRow*ROW_SPACING);
      if(keys['KeyQ']) joints.yaw+=jointSpeed*dt; if(keys['KeyA']) joints.yaw-=jointSpeed*dt; joints.yaw=THREE.MathUtils.clamp(joints.yaw,-170,170);
      if(keys['KeyW']) joints.shoulder+=jointSpeed*dt; if(keys['KeyS']) joints.shoulder-=jointSpeed*dt; joints.shoulder=THREE.MathUtils.clamp(joints.shoulder,-20,110);
      if(keys['KeyE']) joints.elbow+=jointSpeed*dt; if(keys['KeyD']) joints.elbow-=jointSpeed*dt; joints.elbow=THREE.MathUtils.clamp(joints.elbow,-10,140);
      if(keys['KeyR']) joints.wristPitch+=jointSpeed*dt; if(keys['KeyF']) joints.wristPitch-=jointSpeed*dt; joints.wristPitch=THREE.MathUtils.clamp(joints.wristPitch,-90,90);
      if(keys['KeyT']) joints.wristRoll+=jointSpeed*dt; if(keys['KeyG']) joints.wristRoll-=jointSpeed*dt; joints.wristRoll=THREE.MathUtils.clamp(joints.wristRoll,-180,180);
    }
    applyJoints();
  }

  reachSphere.visible=mode==='Work';
  const eef=new THREE.Vector3();
  axes.getWorldPosition(eef);
  hud.innerHTML=`Mode: ${mode} Row:${currentRow} X:${xPos.toFixed(2)}m<br>EEF: ${eef.x.toFixed(2)},${eef.y.toFixed(2)},${eef.z.toFixed(2)}<br>Tool:${toolMode} Battery:100% Link:100%`;
  renderer.render(scene,camera);
}

animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
